import { EventEmitter } from 'events';
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs';


function depthOf(object) {
    let depth, key, level;
    level = 1;
    for ( key in object ) {
        if ( ! Object.prototype.hasOwnProperty.call(object, key) ) continue;
        if ( typeof object[ key ] === 'object' ) {
            depth = depthOf(object[ key ]) + 1;
            level = Math.max(depth, level);
        }
    }
    return level;
}

/**
 * Copy/paste from Omelette (0.4.4), converted to TS
 * Also includes https://github.com/f/omelette/pull/14
 * @copyright Fatih Kadir AkÄ±n <fka@fatihak.in>
 * @license MIT
 */
export class Completion extends EventEmitter {
    private compgen: number | any;
    private install: boolean;
    private installFish: boolean;
    private isDebug: boolean;
    private fragment: number;
    private line: string | any;
    private word: any;
    private HOME: any;
    private SHELL: any;
    private program: any;
    private programs: any[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | any;
    private fragments: any;
    private shell: string;

    constructor() {
        super()
        let isFish, isZsh, ref, ref1;
        this.compgen     = process.argv.indexOf('--compgen');
        this.install     = process.argv.indexOf('--completion') > - 1;
        this.installFish = process.argv.indexOf('--completion-fish') > - 1;
        isZsh            = process.argv.indexOf('--compzsh') > - 1;
        isFish           = process.argv.indexOf('--compfish') > - 1;
        this.isDebug     = process.argv.indexOf('--debug') > - 1;
        this.fragment    = parseInt(process.argv[ this.compgen + 1 ]) - (isZsh ? 1 : 0);
        this.line        = process.argv[ this.compgen + 3 ];
        this.word        = (ref = this.line) != null ? ref.trim().split(/\s+/).pop() : void 0;
        ref1             = process.env;
        this.HOME        = ref1.HOME;
        this.SHELL       = ref1.SHELL;
    }


    setProgram(programs) {
        programs     = programs.split('|');
        this.program = programs[ 0 ];
        return this.programs = programs.map(function (program) {
            return program.replace(/[^A-Za-z0-9\.\_\-]/g, '');
        });
    };

    setFragments() {
        let fragments1;
        fragments1     = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
        this.fragments = fragments1;
    };

    generate() {
        let data;
        data = {
            before  : this.word,
            fragment: this.fragment,
            line    : this.line,
            reply   : this.reply
        };
        this.emit('complete', this.fragments[ this.fragment - 1 ], data);
        this.emit(this.fragments[ this.fragment - 1 ], data);
        this.emit('$' + this.fragment, data);
        return process.exit();
    };

    reply(words) {
        if ( words == null ) {
            words = [];
        }
        console.log(typeof words.join === 'function' ? words.join(os.EOL) : void 0);
        return process.exit();
    };

    tree(objectTree) {
        let depth, i, level, ref;
        if ( objectTree == null ) {
            objectTree = {};
        }
        depth = depthOf(objectTree);
        for ( level = i = 1, ref = depth; 1 <= ref ? i <= ref : i >= ref; level = 1 <= ref ? ++ i : -- i ) {
            this.on('$' + level, function (arg) {
                let accessor, fragment, line, replies, reply;
                fragment = arg.fragment;
                reply    = arg.reply;
                line     = arg.line;
                accessor = new Function('_', 'return _[\'' + (line.split(/\s+/).slice(1, - 1).filter(Boolean).join('\'][\'')) + '\']');
                replies  = fragment === 1 ? Object.keys(objectTree) : accessor(objectTree);
                return reply((function (replies) {
                    if ( replies instanceof Function ) {
                        return replies();
                    }
                    if ( replies instanceof Array ) {
                        return replies;
                    }
                    if ( replies instanceof Object ) {
                        return Object.keys(replies);
                    }
                })(replies));
            });
        }
        return this;
    };

    generateCompletionCode() {
        let completions;
        completions = this.programs.map((program) => {
            let completion;
            completion = '_' + program + '_completion';
            return '### ' + program + ' completion - begin. generated by omelette.js ###\nif type compdef &>/dev/null; then\n  ' + completion + '() {\n    compadd -- `' + this.program + ' --compzsh --compgen "${CURRENT}" "${words[CURRENT-1]}" "${BUFFER}"`\n  }\n  compdef ' + completion + ' ' + program + '\nelif type complete &>/dev/null; then\n  ' + completion + '() {\n    COMPREPLY=( $(compgen -W \'$(' + this.program + ' --compbash --compgen "${COMP_CWORD}" "${COMP_WORDS[COMP_CWORD-1]}" "${COMP_LINE}")\' -- "${COMP_WORDS[COMP_CWORD]}") )\n  }\n  complete -F ' + completion + ' ' + program + '\nfi\n### ' + program + ' completion - end ###';
        });
        if ( this.isDebug ) {
            completions.push(this.generateTestAliases());
        }
        return completions.join(os.EOL);
    };

    generateCompletionCodeFish() {
        let completions;
        completions = this.programs.map((program) => {
            let completion;
            completion = '_' + program + '_completion';
            return '### ' + program + ' completion - begin. generated by omelette.js ###\nfunction ' + completion + '\n  ' + this.program + ' --compfish --compgen (count (commandline -poc)) (commandline -pt) (commandline -pb)\nend\ncomplete -f -c ' + program + ' -a \'(' + completion + ')\'\n### ' + program + ' completion - end ###';
        });
        if ( this.isDebug ) {
            completions.push(this.generateTestAliases());
        }
        return completions.join(os.EOL);
    };

    generateTestAliases() {
        let debugAliases, debugUnaliases, fullPath;
        fullPath       = path.join(process.cwd(), this.program);
        debugAliases   = this.programs.map(function (program) {
            return '  alias ' + program + '=' + fullPath;
        }).join(os.EOL);
        debugUnaliases = this.programs.map(function (program) {
            return '  unalias ' + program;
        }).join(os.EOL);
        return '### test method ###\nomelette-debug-' + this.program + '() {\n' + debugAliases + '\n}\nomelette-nodebug-' + this.program + '() {\n' + debugUnaliases + '\n}\n### tests ###';
    };

    checkInstall() {
        if ( this.install ) {
            console.log(this.generateCompletionCode());
            process.exit();
        }
        if ( this.installFish ) {
            console.log(this.generateCompletionCodeFish());
            return process.exit();
        }
    };

    getActiveShell() {
        let SHELL;
        SHELL = process.env.SHELL;
        if ( SHELL.match(/bash/) ) {
            return 'bash';
        } else if ( SHELL.match(/zsh/) ) {
            return 'zsh';
        } else if ( SHELL.match(/fish/) ) {
            return 'fish';
        }
    };

    getDefaultShellInitFile() {
        let fileAt, fileAtHome;
        fileAt     = function (root) {
            return function (file) {
                return path.join(root, file);
            };
        };
        fileAtHome = fileAt(this.HOME);
        switch ( this.shell = this.getActiveShell() ) {
            case 'bash':
                return fileAtHome('.bash_profile');
            case 'zsh':
                return fileAtHome('.zshrc');
            case 'fish':
                return fileAtHome('.config/fish/config.fish');
        }
    };

    setupShellInitFile(initFile) {
        let completionPath, programFolder, template;
        if ( initFile == null ) {
            initFile = this.getDefaultShellInitFile();
        }
        template = () => {
            return function (command) {
                return '\n# begin ' + this.program + ' completion\n' + command + '\n# end ' + this.program + ' completion\n';
            };
        }
        switch ( this.shell ) {
            case 'bash':
                programFolder  = path.join(this.HOME, '.' + this.program);
                completionPath = path.join(programFolder, 'completion.sh');
                if ( ! fs.existsSync(programFolder) ) {
                    fs.mkdirSync(programFolder);
                }
                fs.writeFileSync(completionPath, this.generateCompletionCode());
                fs.appendFileSync(initFile, template('source ' + completionPath));
                break;
            case 'zsh':
                fs.appendFileSync(initFile, template('. <(' + this.program + ' --completion)'));
                break;
            case 'fish':
                fs.appendFileSync(initFile, template(this.program + ' --completion-fish | source'));
        }
        return process.exit();
    };

    init() {
        if ( this.compgen > - 1 ) {
            return this.generate();
        }
    };

}


export function completion(...a: any[]) {

    let _completion, args, callback, callbacks, fn, fragment, fragments, i, index, len, program, ref, ref1, template;

    template = a[ 0 ];
    args     = 2 <= a.length ? Array.prototype.slice.call(a, 1) : [];

    if ( template instanceof Array && args.length > 0 ) {
        ref       = [ template[ 0 ].trim(), args ];
        program   = ref[ 0 ];
        callbacks = ref[ 1 ];
        fragments = callbacks.map(function (callback, index) {
            return 'arg' + index;
        });
    } else {
        ref1      = template.split(/\s+/);
        program   = ref1[ 0 ];
        fragments = 2 <= ref1.length ? Array.prototype.slice.call(ref1, 1) : [];
        callbacks = [];
    }
    fragments   = fragments.map(function (fragment) {
        return fragment.replace(/^\<+|\>+$/g, '');
    });
    _completion = new Completion();
    _completion.setProgram(program);
    _completion.setFragments.apply(_completion, fragments);
    _completion.checkInstall();
    fn = function (callback) {
        return _completion.on(fragment, function () {
            var args;
            args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
            return this.reply(callback instanceof Array ? callback : callback.apply(null, args));
        });
    };
    for ( index = i = 0, len = callbacks.length; i < len; index = ++ i ) {
        callback = callbacks[ index ];
        fragment = 'arg' + index;
        fn(callback);
    }
    return _completion;
}